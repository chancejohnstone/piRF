cov2[b] <- getCoverage(verf_int2, verf)
avgl2[b] <- getPILength(verf_int2)
}
c <- cbind(cov1, cov2)
l <- cbind(avgl1, avgl2)
boxplot(c)
boxplot(l)
#plot last set of prediction intervals
par(mfrow = c(1,2))
col <- ((verf$response >= verf_int1[,1]) * (verf$response <= verf_int1[,2])-1)*(-1)+1
plot(x = verf_preds1, y = verf$response, pch = 20,
col = "black", ylab = "true", xlab = "predicted", main = "no debiasing",
xlim = c(100,150), ylim = c(100,150))
abline(a = 0, b = 1)
segments(x0 = verf_int1[,1], x1 = verf_int1[,2], y1 = verf$response, y0 = verf$response, lwd = 1, col = col)
col <- ((verf$response >= verf_int2[,1]) * (verf$response <= verf_int2[,2])-1)*(-1)+1
plot(x = verf_preds2, y = verf$response, pch = 20,
col = "black", ylab = "true", xlab = "predicted", main = "debiasing",
xlim = c(100,150), ylim = c(100,150))
abline(a = 0, b = 1)
segments(x0 = verf_int2[,1], x1 = verf_int2[,2], y1 = verf$response, y0 = verf$response, lwd = 1, col = col)
#cross validated with respect to prediction intervals
boost_vecs <- c(1,2,3,4,5,6,7,8,9,10)
B <- 50
cov <- avgl <- mse <- matrix(0, nrow = B, ncol = length(boost_vecs))
for(boost in boost_vecs){
for(b in 1:B){
id <- split(1:n, sample(1:3,n, replace = TRUE))
train <- airfoil[id[[1]],]
test <- airfoil[id[[2]],]
verf <- airfoil[id[[3]],]
verf <- verf[sample(1:nrow(verf), 50),]
res <- ranger(response~., data = train)
#fit to bias; get bias fits
bias <- matrix(0, nrow = nrow(train), ncol = boost + 1)
bias_preds <- matrix(0, nrow = nrow(train), ncol = boost + 1)
bias_res <- list()
bias_preds[,1] <- 0
for(j in 2:(boost+1)){
bias[,j] <- train$response - (res$predictions + apply(bias_preds, FUN = sum, MARGIN = 1))
bias_data <- data.frame(bias[,j], train[,-6])
names(bias_data)[1] <- c("bias")
bias_res[[j]] <- ranger(bias~., data = bias_data, num.trees = 100)
bias_preds[,j] <- bias_res[[j]]$predictions
}
#get verification predictions
add_test <- rep(0, times = nrow(test))
add <- rep(0, times = nrow(verf))
for(j in 2:(boost+1)){
add_test <- add_test + predict(bias_res[[j]], test)$predictions
add <- add + predict(bias_res[[j]], verf)$predictions
}
conf <- test$response - (predict(res, test)$predictions + add_test)
q <- quantile(conf, probs = c(alpha/2, 1-alpha/2))
verf_preds <- predict(res, verf)$predictions + add
verf_int <- matrix(verf_preds, nrow = nrow(verf), ncol = 2) + matrix(q, nrow = nrow(verf), ncol = 2, byrow = TRUE)
mse[b,boost] <- sum((verf$response - verf_preds)^2)
cov[b,boost] <- getCoverage(verf_int, verf)
avgl[b,boost] <- getPILength(verf_int)
}
col <- ((verf$response >= verf_int[,1]) * (verf$response <= verf_int[,2])-1)*(-1)+1
plot(x = verf_preds, y = verf$response, pch = 20,
col = "black", ylab = "true", xlab = "predicted", main = boost)
abline(a = 0, b = 1)
segments(x0 = verf_int[,1], x1 = verf_int[,2], y1 = verf$response, y0 = verf$response, lwd = 1, col = col)
}
plot(apply(mse, FUN = mean, MARGIN = 2), type = "l")
plot(apply(avgl, FUN = mean, MARGIN = 2), type = "l")
mse_min <- which.min(apply(mse, FUN = mean, MARGIN = 2))
avgl_min <- which.min(apply(avgl, FUN = mean, MARGIN = 2))
#bias corrected conformal prediction intervals
library(piRF)
library(ranger)
source("C:/Users/thechanceyman/Documents/RFIntervals/R/Simulation Functions.R")
data(airfoil)
names(airfoil)[6] <- "response"
set.seed(2023)
alpha <- .1
n <- nrow(airfoil)
B <- 100
#repeat
cov1 <- cov2 <- avgl1 <- avgl2 <- rep(0, times = B)
for(b in 1:B){
id <- split(1:n, sample(1:3,n, replace = TRUE))
train <- airfoil[id[[1]],]
test <- airfoil[id[[2]],]
verf <- airfoil[id[[3]],]
verf <- verf[sample(1:nrow(verf), 50),]
res <- ranger(response~., data = train)
#conf1 <- train$response - predict(res, train)$predictions
conf1 <- train$response - res$predictions
q1 <- quantile(conf1, probs = c(alpha/2, 1 - alpha/2))
verf_preds1 <- predict(res, verf)$predictions
verf_int1 <- matrix(verf_preds1, nrow = nrow(verf), ncol = 2) + matrix(q1, nrow = nrow(verf), ncol = 2, byrow = TRUE)
cov1[b] <- getCoverage(verf_int1, verf)
avgl1[b] <- getPILength(verf_int1)
#correct bias
#bias <- train$response - predict(res, train)$predictions
bias <- conf1
bias_data <- data.frame(bias, train[,-6])
bias_res <- ranger(bias~., data = bias_data, num.trees = 100)
#get quantiles
conf2 <- test$response -  (predict(res, test)$predictions + predict(bias_res, test)$predictions)
q2 <- quantile(conf2, probs = c(alpha/2, 1 - alpha/2))
verf_preds2 <- predict(res, verf)$predictions + predict(bias_res, verf)$predictions
verf_int2 <- matrix(verf_preds2, nrow = nrow(verf), ncol = 2) + matrix(q2, nrow = nrow(verf), ncol = 2, byrow = TRUE)
cov2[b] <- getCoverage(verf_int2, verf)
avgl2[b] <- getPILength(verf_int2)
}
c <- cbind(cov1, cov2)
l <- cbind(avgl1, avgl2)
boxplot(c)
boxplot(l)
#plot last set of prediction intervals
par(mfrow = c(1,2))
col <- ((verf$response >= verf_int1[,1]) * (verf$response <= verf_int1[,2])-1)*(-1)+1
plot(x = verf_preds1, y = verf$response, pch = 20,
col = "black", ylab = "true", xlab = "predicted", main = "no debiasing",
xlim = c(100,150), ylim = c(100,150))
abline(a = 0, b = 1)
segments(x0 = verf_int1[,1], x1 = verf_int1[,2], y1 = verf$response, y0 = verf$response, lwd = 1, col = col)
col <- ((verf$response >= verf_int2[,1]) * (verf$response <= verf_int2[,2])-1)*(-1)+1
plot(x = verf_preds2, y = verf$response, pch = 20,
col = "black", ylab = "true", xlab = "predicted", main = "debiasing",
xlim = c(100,150), ylim = c(100,150))
abline(a = 0, b = 1)
segments(x0 = verf_int2[,1], x1 = verf_int2[,2], y1 = verf$response, y0 = verf$response, lwd = 1, col = col)
#cross validated with respect to prediction intervals
boost_vecs <- c(1,2,3,4,5,6,7,8,9,10)
B <- 50
cov <- avgl <- mse <- matrix(0, nrow = B, ncol = length(boost_vecs))
for(boost in boost_vecs){
for(b in 1:B){
id <- split(1:n, sample(1:3,n, replace = TRUE))
train <- airfoil[id[[1]],]
test <- airfoil[id[[2]],]
verf <- airfoil[id[[3]],]
verf <- verf[sample(1:nrow(verf), 50),]
res <- ranger(response~., data = train)
#fit to bias; get bias fits
bias <- matrix(0, nrow = nrow(train), ncol = boost + 1)
bias_preds <- matrix(0, nrow = nrow(train), ncol = boost + 1)
bias_res <- list()
bias_preds[,1] <- 0
for(j in 2:(boost+1)){
bias[,j] <- train$response - (res$predictions + apply(bias_preds, FUN = sum, MARGIN = 1))
bias_data <- data.frame(bias[,j], train[,-6])
names(bias_data)[1] <- c("bias")
bias_res[[j]] <- ranger(bias~., data = bias_data, num.trees = 100)
bias_preds[,j] <- bias_res[[j]]$predictions
}
#get verification predictions
add_test <- rep(0, times = nrow(test))
add <- rep(0, times = nrow(verf))
for(j in 2:(boost+1)){
add_test <- add_test + predict(bias_res[[j]], test)$predictions
add <- add + predict(bias_res[[j]], verf)$predictions
}
conf <- test$response - (predict(res, test)$predictions + add_test)
q <- quantile(conf, probs = c(alpha/2, 1-alpha/2))
verf_preds <- predict(res, verf)$predictions + add
verf_int <- matrix(verf_preds, nrow = nrow(verf), ncol = 2) + matrix(q, nrow = nrow(verf), ncol = 2, byrow = TRUE)
mse[b,boost] <- sum((verf$response - verf_preds)^2)
cov[b,boost] <- getCoverage(verf_int, verf)
avgl[b,boost] <- getPILength(verf_int)
}
col <- ((verf$response >= verf_int[,1]) * (verf$response <= verf_int[,2])-1)*(-1)+1
plot(x = verf_preds, y = verf$response, pch = 20,
col = "black", ylab = "true", xlab = "predicted", main = boost)
abline(a = 0, b = 1)
segments(x0 = verf_int[,1], x1 = verf_int[,2], y1 = verf$response, y0 = verf$response, lwd = 1, col = col)
}
plot(apply(mse, FUN = mean, MARGIN = 2), type = "l")
plot(apply(avgl, FUN = mean, MARGIN = 2), type = "l")
mse_min <- which.min(apply(mse, FUN = mean, MARGIN = 2))
avgl_min <- which.min(apply(avgl, FUN = mean, MARGIN = 2))
mse
apply(mse, FUN = mean, MARGIN = 2)
apply(avgl, FUN = mean, MARGIN = 2)
library(devtools)
document()
setwd("..")
getwd()
install("piRF")
piRF
library(piRF)
?rfint
document()
library(devtools)
document()
getwd()
setwd("~/piRF")
document()
setwd("..")
install("piRF")
library(piRF)
?rfint
library(devtools)
document()
setwd("..")
install("piRF")
library(piRF)
?rfint
document()
library(devtools)
document()
setwd("..")
install("piRF")
library(piRF)
?rfint
library(devtools)
document()
setwd("..")
install("piRF")
setwd("~/piRF")
document()
setwd("..")
install("piRF")
setwd("~/piRF")
document()
setwd("..")
install("piRF")
setwd("~/piRF")
document()
setwd("~/piRF")
setwd("..")
install("piRF")
setwd("~/piRF")
document()
setwd("..")
install("piRF")
library(piRF)
?rfint
library(piRF)
#functions to get average length and average coverage of output
getPILength <- function(x){
#average PI length across each set of predictions
l <- x[,2] - x[,1]
avg_l <- mean(l)
return(avg_l)
}
getCoverage <- function(x, response){
#output coverage for test data
coverage <- sum((response >= x[,1]) * (response <= x[,2]))/length(response)
return(coverage)
}
#import airfoil self noise dataset
data(airfoil)
#generate train and test data
ratio <- .9
nrow <- nrow(airfoil)
n <- floor(nrow*ratio)
samp <- sample(1:nrow, size = n)
train <- airfoil[samp,]
test <- airfoil[-samp,]
#generate prediction intervals
res <- rfint(pressure ~ . , train_data = train, test_data = test,
method = c("quantile", "Zhang", "Tung", "Romano", "Roy", "HDI", "Ghosal"))
#empirical coverage, and average prediction interval length for each method
coverage <- sapply(res, FUN = getCoverage, response = test$pressure)
coverage
length <- sapply(res, FUN = getPILength)
length
#plotting intervals and predictions
par(mfrow = c(2,2))
for(i in 1:7){
col <- ((test$pressure >= res$int[[i]][,1]) * (test$pressure <= res$int[[i]][,2])-1)*(-1)+1
plot(x = res$preds[[i]], y = test$pressure, pch = 20,
col = "black", ylab = "true", xlab = "predicted", main = method_vec[i])
abline(a = 0, b = 1)
segments(x0 = res$int[[i]][,1], x1 = res$int[[i]][,2], y1 = test$pressure, y0 = test$pressure, lwd = 1, col = col)
}
res
res$int
#functions to get average length and average coverage of output
getPILength <- function(x){
#average PI length across each set of predictions
l <- x[,2] - x[,1]
avg_l <- mean(l)
return(avg_l)
}
getCoverage <- function(x, response){
#output coverage for test data
coverage <- sum((response >= x[,1]) * (response <= x[,2]))/length(response)
return(coverage)
}
#import airfoil self noise dataset
data(airfoil)
#generate train and test data
ratio <- .975
nrow <- nrow(airfoil)
n <- floor(nrow*ratio)
samp <- sample(1:nrow, size = n)
train <- airfoil[samp,]
test <- airfoil[-samp,]
#generate prediction intervals
res <- rfint(pressure ~ . , train_data = train, test_data = test,
method = c("quantile", "Zhang", "Tung", "Romano", "Roy", "HDI", "Ghosal"), concise = FALSE)
#empirical coverage, and average prediction interval length for each method
coverage <- sapply(res, FUN = getCoverage, response = test$pressure)
coverage
length <- sapply(res, FUN = getPILength)
length
#plotting intervals and predictions
par(mfrow = c(2,2))
for(i in 1:7){
col <- ((test$pressure >= res$int[[i]][,1]) * (test$pressure <= res$int[[i]][,2])-1)*(-1)+1
plot(x = res$preds[[i]], y = test$pressure, pch = 20,
col = "black", ylab = "true", xlab = "predicted", main = method_vec[i])
abline(a = 0, b = 1)
segments(x0 = res$int[[i]][,1], x1 = res$int[[i]][,2], y1 = test$pressure, y0 = test$pressure, lwd = 1, col = col)
}
test
names(test)
#functions to get average length and average coverage of output
getPILength <- function(x){
#average PI length across each set of predictions
l <- x[,2] - x[,1]
avg_l <- mean(l)
return(avg_l)
}
getCoverage <- function(x, response){
#output coverage for test data
coverage <- sum((response >= x[,1]) * (response <= x[,2]))/length(response)
return(coverage)
}
#import airfoil self noise dataset
data(airfoil)
#generate train and test data
ratio <- .975
nrow <- nrow(airfoil)
n <- floor(nrow*ratio)
samp <- sample(1:nrow, size = n)
train <- airfoil[samp,]
test <- airfoil[-samp,]
#generate prediction intervals
res <- rfint(pressure ~ . , train_data = train, test_data = test,
method = c("quantile", "Zhang", "Tung", "Romano", "Roy", "HDI", "Ghosal"), concise = FALSE)
#empirical coverage, and average prediction interval length for each method
coverage <- sapply(res$int, FUN = getCoverage, response = test$pressure)
coverage
length <- sapply(res, FUN = getPILength)
length
#plotting intervals and predictions
par(mfrow = c(2,2))
for(i in 1:7){
col <- ((test$pressure >= res$int[[i]][,1]) * (test$pressure <= res$int[[i]][,2])-1)*(-1)+1
plot(x = res$preds[[i]], y = test$pressure, pch = 20,
col = "black", ylab = "true", xlab = "predicted", main = method_vec[i])
abline(a = 0, b = 1)
segments(x0 = res$int[[i]][,1], x1 = res$int[[i]][,2], y1 = test$pressure, y0 = test$pressure, lwd = 1, col = col)
}
#functions to get average length and average coverage of output
getPILength <- function(x){
#average PI length across each set of predictions
l <- x[,2] - x[,1]
avg_l <- mean(l)
return(avg_l)
}
getCoverage <- function(x, response){
#output coverage for test data
coverage <- sum((response >= x[,1]) * (response <= x[,2]))/length(response)
return(coverage)
}
#import airfoil self noise dataset
data(airfoil)
#generate train and test data
ratio <- .975
nrow <- nrow(airfoil)
n <- floor(nrow*ratio)
samp <- sample(1:nrow, size = n)
train <- airfoil[samp,]
test <- airfoil[-samp,]
#generate prediction intervals
res <- rfint(pressure ~ . , train_data = train, test_data = test,
method = c("quantile", "Zhang", "Tung", "Romano", "Roy", "HDI", "Ghosal"), concise = FALSE)
#empirical coverage, and average prediction interval length for each method
coverage <- sapply(res$int, FUN = getCoverage, response = test$pressure)
coverage
length <- sapply(res$int, FUN = getPILength)
length
#plotting intervals and predictions
par(mfrow = c(2,2))
for(i in 1:7){
col <- ((test$pressure >= res$int[[i]][,1]) * (test$pressure <= res$int[[i]][,2])-1)*(-1)+1
plot(x = res$preds[[i]], y = test$pressure, pch = 20,
col = "black", ylab = "true", xlab = "predicted", main = method_vec[i])
abline(a = 0, b = 1)
segments(x0 = res$int[[i]][,1], x1 = res$int[[i]][,2], y1 = test$pressure, y0 = test$pressure, lwd = 1, col = col)
}
document()
library(devtools)
library(devtools)
document()
setwd("..")
install("piRF")
library(piRF)
?rfint
setwd("~/piRF")
document(0)
document()
library(devtools)
library(devtools)
document()
setwd("..")
install(piRF)
install("piRF")
setwd("~/piRF")
document()
setwd("..")
install("piRF")
setwd("~/piRF")
document()
setwd("..")
install("piRF")
setwd("~/piRF")
document()
setwd("..")
install("piRF")
library(piRF)
library(piRF)
?rfint
library(devtools)
setwd("~/piRF")
document()
setwd("..")
install("piRF")
library(piRF)
?rfint
setwd("~/piRF")
library(devtools)
document()
setwd("..")
install("piRF")
setwd("..")
library(devtools)
document()
setwd("~/piRF")
document()
setwd("..")
install("piRF")
library(piRF)
?rfint
library(Rdpack)
setwd("~/piRF")
document()
library(devtools)
document()
setwd("..")
install("piRF")
library(devtools)
library(piRF)
?rfint
setwd("~/piRF")
document()
setwd("..")
install("piRF")
library(devtools)
library(piRF)
?rfint
setwd("~/piRF")
document()
setwd("..")
install("piRF")
install("piRF")
install("piRF")
install("piRF")
install.packages("glue")
install.packages("glue")
install("piRF")
library(devtools)
install("piRF")
library(piRF)
library(piRF)
library(devtools)
?rfint
library(rfinterval)
?rfinterval
setwd("~/piRF")
library(devtools)
document()
setwd("..")
install("piRF")
library(piRF)
?rfint
library(devtools)
setwd("~/piRF")
document()
setwd("..")
install("piRF")
library(devtools)
install("piRF")
library(devtools)
library(piRF)
?rfint
setwd("~/piRF")
document()
install("piRF")
setwd("..")
install("piRF")
library(devtools)
library(piRF)
?airfoil
piRF::CQRF()
piRF::CQRF
library(devtools)
setwd("~/piRF")
document()
setwd("..")
install("piRF")
library(piRF)
?rfint
